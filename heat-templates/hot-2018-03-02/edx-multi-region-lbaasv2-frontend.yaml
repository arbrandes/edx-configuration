# This template defines a frontend Open edX environment. It creates a a
# configurable number of ephemeral application servers, and a load balancing
# pool behind a floating IP.
heat_template_version: 2018-03-02

description: >
  Full Open edX deployment: 3 backend nodes, configurable number of application
  servers behind a load balancer.

parameters:
  cidr_base:
    type: string
    description: Subnet CIDR base
  backend_router_public_ip:
    type: string
    description: The VPN peer's router external IP
  backend_subnet_cidr:
    type: string
    description: The VPN peer's subnet CIDR
    default: 192.168.122.0/24
  vpn_psk:
    type: string
    description: The VPN peer's IPSEC secret
  preferred_provider:
    type: string
    description: The preferred hastexo XBlock provider for this region
  app_image:
    type: string
    description: >
      Image ID or name.
      Should be a distribution platform supported for Open edX.
    default: ubuntu-16.04-server-cloudimg
  tmp_app_image:
    type: string
    description: >
      Image ID or name.
      Should be a distribution platform supported for Open edX.
    default: ubuntu-16.04-server-cloudimg
  app_flavor:
    type: string
    description: Flavor to use for app servers
    default: m1.large
  app_count:
    type: number
    description: Number of app servers
    default: 1
  tmp_app_count:
    type: number
    description: Number of new app servers
    default: 0
  app_http_port:
    type: number
    description: Load balancer HTTP port for app servers
    default: 80
  app_https_port:
    type: number
    description: Load balancer HTTPS port for app servers
    default: 443
  app_ips:
    type: json
    default:
      '0': 150
      '1': 151
      '2': 152
      '3': 153
      '4': 154
      '5': 155
      '6': 156
      '7': 157
      '8': 158
      '9': 159
      '10': 160
      '11': 161
      '12': 162
      '13': 163
      '14': 164
      '15': 165
      '16': 166
      '17': 167
      '18': 168
      '19': 169
  tmp_app_ips:
    type: json
    default:
      '0': 180
      '1': 181
      '2': 182
      '3': 183
      '4': 184
      '5': 185
      '6': 186
      '7': 187
      '8': 188
      '9': 189
      '10': 190
      '11': 191
      '12': 192
      '13': 193
      '14': 194
      '15': 195
      '16': 196
      '17': 197
      '18': 198
      '19': 199
  public_net_id:
    type: string
    description: Public network ID
  key_name:
    type: string
    description: >
      SSH key name for authentication, to be injected into the servers
      for the default user
  timeout:
    type: number
    description: Stack creation timeout (seconds)
    default: 900

resources:
  # server_security_group: Neutron security group allowing inbound
  # access on selected ports
  #
  # We allow inbound ICMP, SSH, and TCP on the app http/s ports.
  server_security_group:
    type: OS::Neutron::SecurityGroup
    properties:
      description: Neutron security group rules
      name: server_security_group
      rules:
      - remote_mode: 'remote_group_id'
        direction: ingress
      - remote_ip_prefix: 0.0.0.0/0
        protocol: tcp
        direction: ingress
        port_range_min: 22
        port_range_max: 22
      - remote_ip_prefix: 0.0.0.0/0
        protocol: icmp
      - remote_ip_prefix: 0.0.0.0/0
        protocol: tcp
        direction: ingress
        port_range_min: { get_param: app_http_port }
        port_range_max: { get_param: app_http_port }
      - remote_ip_prefix: 0.0.0.0/0
        protocol: tcp
        direction: ingress
        port_range_min: { get_param: app_https_port }
        port_range_max: { get_param: app_https_port }
      - remote_ip_prefix: 192.168.0.0/16
        protocol: tcp
        direction: ingress
        port_range_min: 1
        port_range_max: 65535

  # management_net: private Neutron network
  management_net:
    type: OS::Neutron::Net
    properties:
      name: management-net

  # management_sub_net: private Neutron subnet
  #
  # We assign dynamic private (fixed) IPv4 addresses upward of
  # A.B.C.200. Any statically configured addresses in this
  # subnet must use IP addresses below .200.
  management_sub_net:
    type: OS::Neutron::Subnet
    properties:
      name: management-sub-net
      network_id: { get_resource: management_net }
      cidr:
        str_replace:
          template: "{ cidr_base }.0/24"
          params: {"{ cidr_base }": { get_param: cidr_base }}
      gateway_ip:
        str_replace:
          template: "{ cidr_base }.1"
          params: {"{ cidr_base }": { get_param: cidr_base }}
      enable_dhcp: true
      allocation_pools:
        - start:
            str_replace:
              template: "{ cidr_base }.200"
              params: {"{ cidr_base }": { get_param: cidr_base }}
          end:
            str_replace:
              template: "{ cidr_base }.254"
              params: {"{ cidr_base }": { get_param: cidr_base }}

  # router: private router
  #
  # Connects our private subnet to the floating IP network.
  router:
    type: OS::Neutron::Router

  # router_gateway
  #
  # Sets the public network as the router's gateway.
  router_gateway:
    type: OS::Neutron::RouterGateway
    properties:
      router_id: { get_resource: router }
      network_id: { get_param: public_net_id }

  # router_interface
  #
  # Plugs the management subnet into the router.
  router_interface:
    type: OS::Neutron::RouterInterface
    properties:
      router_id: { get_resource: router }
      subnet_id: { get_resource: management_sub_net }

  ike_policy:
    type: OS::Neutron::IKEPolicy

  ipsec_policy:
    type: OS::Neutron::IPsecPolicy

  vpn_service:
    type: OS::Neutron::VPNService
    properties:
      router: { get_resource: router }
      subnet: { get_resource: management_sub_net }
    depends_on:
      - router_gateway
      - router_interface

  backend_vpn_connection:
    type: OS::Neutron::IPsecSiteConnection
    properties:
      ikepolicy_id: { get_resource: ike_policy }
      ipsecpolicy_id: { get_resource: ipsec_policy }
      vpnservice_id: { get_resource: vpn_service }
      peer_address: { get_param: backend_router_public_ip }
      peer_id: { get_param: backend_router_public_ip }
      peer_cidrs: [{ get_param: backend_subnet_cidr }]
      psk: { get_param: vpn_psk }
    depends_on:
      - vpn_service

  # common_config_part: cloud-init configuration common to all nodes
  common_config_part:
    type: OS::Heat::SoftwareConfig
    properties:
      config: { get_file: ../cloud-config/common.yaml }

  hosts_config_part:
    type: OS::Heat::SoftwareConfig
    properties:
      config: { get_file: ../cloud-config/hosts.yaml }

  # app_server_group: a server group for app servers
  #
  # Set a soft anti-affinity policy, to minimize the effect of compute node
  # failures on the functioning of the cluster.
  app_server_group:
    type: OS::Nova::ServerGroup
    properties:
      name: app_server_group
      policies: ["soft-anti-affinity"]

  # app_servers: creates an application server cluster of a
  # configurable size
  #
  # App servers are named app0 ... appN, where N == app_count - 1.
  app_servers:
    type: OS::Heat::ResourceGroup
    depends_on: management_sub_net
    properties:
      count: { get_param: app_count }
      resource_def:
        type: edx-app-server-multi-region-lbaasv2.yaml
        properties:
          name: app%index%
          index: '%index%'
          cidr_base: { get_param: cidr_base }
          ip_map: { get_param: app_ips }
          flavor: { get_param: app_flavor }
          image: { get_param: app_image }
          key_name: { get_param: key_name }
          http_pool: { get_resource: app_server_http_pool }
          http_port: { get_param: app_http_port }
          https_pool: { get_resource: app_server_https_pool }
          https_port: { get_param: app_https_port }
          metadata: { "metering.stack": { get_param: "OS::stack_id" } }
          network: { get_resource: management_net }
          preferred_provider: { get_param: preferred_provider }
          subnet: { get_resource: management_sub_net }
          security_group: { get_resource: server_security_group }
          server_group: { get_resource: app_server_group }

  # tmp_app_servers: roll out new app servers while the old ones
  # still exist, for a poor man's rolling update
  tmp_app_servers:
    type: OS::Heat::ResourceGroup
    depends_on: management_sub_net
    properties:
      count: { get_param: tmp_app_count }
      resource_def:
        type: edx-app-server-multi-region-lbaasv2.yaml
        properties:
          name: tmpapp%index%
          index: '%index%'
          cidr_base: { get_param: cidr_base }
          ip_map: { get_param: tmp_app_ips }
          flavor: { get_param: app_flavor }
          image: { get_param: tmp_app_image }
          key_name: { get_param: key_name }
          http_pool: { get_resource: app_server_http_pool }
          http_port: { get_param: app_http_port }
          https_pool: { get_resource: app_server_https_pool }
          https_port: { get_param: app_https_port }
          metadata: { "metering.stack": { get_param: "OS::stack_id" } }
          network: { get_resource: management_net }
          preferred_provider: { get_param: preferred_provider }
          subnet: { get_resource: management_sub_net }
          security_group: { get_resource: server_security_group }
          server_group: { get_resource: app_server_group }

  # app_server_lb: Neutron LBaaS v2 load balancer
  app_server_lb:
    type: OS::Neutron::LBaaS::LoadBalancer
    properties:
      vip_subnet: { get_resource: management_sub_net }

  app_server_http_listener:
    type: OS::Neutron::LBaaS::Listener
    properties:
      loadbalancer: { get_resource: app_server_lb }
      protocol: TCP
      protocol_port: { get_param: app_http_port }

  app_server_https_listener:
    type: OS::Neutron::LBaaS::Listener
    properties:
      loadbalancer: { get_resource: app_server_lb }
      protocol: TCP
      protocol_port: { get_param: app_https_port }

  app_server_http_pool:
    type: OS::Neutron::LBaaS::Pool
    properties:
      lb_algorithm: LEAST_CONNECTIONS
      listener: { get_resource: app_server_http_listener }
      protocol: TCP

  app_server_https_pool:
    type: OS::Neutron::LBaaS::Pool
    properties:
      lb_algorithm: LEAST_CONNECTIONS
      listener: { get_resource: app_server_https_listener }
      protocol: TCP

  app_server_http_monitor:
    type: OS::Neutron::LBaaS::HealthMonitor
    properties:
      type: TCP
      delay: 5
      max_retries: 5
      pool: { get_resource: app_server_http_pool }
      timeout: 5

  app_server_https_monitor:
    type: OS::Neutron::LBaaS::HealthMonitor
    properties:
      type: TCP
      delay: 5
      max_retries: 5
      pool: { get_resource: app_server_https_pool }
      timeout: 5

  # app_server_floating_ip: Neutron LBaaS floating IP address
  #
  # Defines a floating IP address linked to the load balancer's
  # private virtual IP (VIP).
  app_server_floating_ip:
    type: OS::Neutron::FloatingIP
    properties:
      floating_network_id: { get_param: public_net_id }
      port_id: { get_attr: [ app_server_lb, vip_port_id ] }

outputs:
  app_ip:
    description: IP address of the app_server group.
    value: { get_attr: [ app_server_floating_ip, floating_ip_address ] }
  frontend_router_public_ip:
    description: IP address of the router in the public network
    value: { get_attr: [ router, external_gateway_info, external_fixed_ips, 0, ip_address ] }
  frontend_subnet_cidr:
    description: CIDR of the management subnet
    value: { get_attr: [ management_sub_net, cidr ] }
